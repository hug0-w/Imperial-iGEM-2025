<!doctype html>
<html lang="en">

<head>
    <!-- iGEM Required Meta Tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="https://static.igem.wiki/teams/5916/assets/images/logo-bg.webp" sizes="192x192" />
    <link rel="license" href="https://creativecommons.org/licenses/by/4.0/" />



    <link href="{{ url_for('static', filename='bootstrap.min.css') }}" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename = 'style.css') }}" rel="stylesheet">

    <title>{% block title %}{% endblock %} | Imperial - iGEM 2025</title>
</head>

<body class="{% block body_class %}{% endblock %}">

    <div id="orientation-overlay">
        <div class="orientation-message">
            <div class="phone-icon"></div>
            <p>Please rotate your device to landscape mode for the best viewing experience.</p>
        </div>
    </div>

    <canvas id="geometric-canvas"></canvas>


    {% block scroll_nav %}{% endblock %}

    <!-- Navigation -->

    <div id="fixed-header-container">
        {% include 'menu.html' %}
    </div>

    <div id="top-hover-trigger"></div>

    <!-- Page Content -->
    <div class="content">
        {% block page_content %}{% endblock %}
    </div>


    <script src="{{ url_for('static', filename='bootstrap.bundle.min.js') }}"></script>

    <!-- Footer -->
    {% include 'footer.html' %}

    <!-- Animation & Scrollspy Script -->
    <script>

        const canvas = document.getElementById('geometric-canvas');
        const ctx = canvas.getContext('2d');
        const mainHeader = document.querySelector('.main-header');
        const contentBox = document.querySelector('.content');
        const sideScrollNav = document.querySelector('.side-scroll-nav');

        const TILE_SIZE = 50;
        const SCROLL_SENSITIVITY = 0.1;

        let scrollY = 0;
        let columnSpeeds = [];

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let x = 0; x < canvas.width; x += TILE_SIZE) {
                const colIndex = Math.floor(x / TILE_SIZE);
                if (!columnSpeeds[colIndex]) return;
                const verticalOffset = scrollY * SCROLL_SENSITIVITY * columnSpeeds[colIndex];
                for (let y = 0; y < canvas.height + TILE_SIZE; y += TILE_SIZE) {
                    const opacity = (Math.sin(y * 0.01 + x * 0.01) + 1) / 2;
                    ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.005})`;
                    ctx.fillRect(x, y - (verticalOffset % (canvas.height + TILE_SIZE)), TILE_SIZE - 2, TILE_SIZE - 2);
                }
            }
        }

        function onResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            columnSpeeds = [];
            const numColumns = Math.ceil(canvas.width / TILE_SIZE);
            for (let i = 0; i < numColumns; i++) {
                columnSpeeds.push(Math.random() * 0.5 + 0.5);
            }
            drawGrid();
        }

        function onScroll() {
            scrollY = window.pageYOffset || document.documentElement.scrollTop;
            requestAnimationFrame(drawGrid);

        }

        window.addEventListener('resize', onResize);
        window.addEventListener('scroll', onScroll);
        onResize();



        // Scrollspy 
        const sections = document.querySelectorAll('.page-section');
        const navLinks = document.querySelectorAll('.scroll-nav a');

        const scrollSpyObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const id = entry.target.getAttribute('id');
                const navLink = document.querySelector(`.scroll-nav a[href="#${id}"]`);

                if (entry.isIntersecting) {
                    navLinks.forEach(link => link.classList.remove('active'));
                    if (navLink) {
                        navLink.classList.add('active');
                    }
                }
            });
        }, {
            rootMargin: '-50% 0px -50% 0px'
        });

        sections.forEach(section => {
            scrollSpyObserver.observe(section);
        });


        // Scroll Animation Script
        const sectionsToAnimate = document.querySelectorAll('.animate-on-scroll');
        const animationObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('is-visible');
                } else {
                    entry.target.classList.remove('is-visible');
                }
            });
        }, {
            threshold: 0.25
        });

        sectionsToAnimate.forEach(section => {
            animationObserver.observe(section);
        });
    </script>


    <script>
        document.addEventListener("DOMContentLoaded", function () {

            const headerContainer = document.getElementById("fixed-header-container");
            const hoverTrigger = document.getElementById("top-hover-trigger");
            const sideScrollNav = document.querySelector(".side-scroll-nav");

            if (!headerContainer || !hoverTrigger) return;

            const scrollThreshold = 70;

            function handleScroll() {
                if (window.scrollY > scrollThreshold) {
                    headerContainer.classList.add("hidden-by-scroll");
                    hoverTrigger.style.display = "block";
                    if (sideScrollNav) sideScrollNav.classList.add("is-visible");
                } else {
                    headerContainer.classList.remove("hidden-by-scroll");
                    headerContainer.classList.remove("visible-by-hover");
                    hoverTrigger.style.display = "none";
                    if (sideScrollNav) sideScrollNav.classList.remove("is-visible");
                }
            }


            window.addEventListener("scroll", handleScroll);

            hoverTrigger.addEventListener("mouseenter", function () {
                headerContainer.classList.add("visible-by-hover");
            });

            headerContainer.addEventListener("mouseleave", function () {
                headerContainer.classList.remove("visible-by-hover");
            });
        });
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {



        const scrollThreshold = 100;


            const transformingTextElements = document.querySelectorAll('.transforming-text-container');


            function handleTextTransform() {

                const currentScrollY = window.scrollY;


                if (currentScrollY > scrollThreshold) {

                    transformingTextElements.forEach(el => el.classList.add('is-transformed'));
                } else {

                    transformingTextElements.forEach(el => el.classList.remove('is-transformed'));
                }
            }


            window.addEventListener('scroll', handleTextTransform);
        });
    </script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const chartContainers = document.querySelectorAll('.data-viz-container');

            if (chartContainers.length === 0) return;

            const animateChart = (container) => {
                const rows = container.querySelectorAll('.chart-row');
                const maxValue = 62;

                rows.forEach(row => {
                    const value = parseFloat(row.dataset.value);
                    const bar = row.querySelector('.chart-bar');
                    if (bar && value) {

                        const width = (value / maxValue) * 100;
                        bar.style.width = `${width}%`;
                    }
                });
            };

            const chartObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        animateChart(entry.target);

                        observer.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.5
            });

            chartContainers.forEach(container => {
                chartObserver.observe(container);
            });
        });
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const counters = document.querySelectorAll('.stat-number');
            if (counters.length === 0) return;

            const animateValue = (element, start, end, duration) => {
                let startTime = null;
                const step = (currentTime) => {
                    if (!startTime) startTime = currentTime;
                    const progress = Math.min((currentTime - startTime) / duration, 1);
                    const currentValue = Math.floor(progress * (end - start) + start);


                    element.innerText = currentValue.toLocaleString('en-US');

                    if (progress < 1) {
                        window.requestAnimationFrame(step);
                    }
                };
                window.requestAnimationFrame(step);
            };

            const counterObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const counter = entry.target;
                        const targetValue = parseFloat(counter.dataset.target);
                        animateValue(counter, 0, targetValue, 3000);
                        observer.unobserve(counter);
                    }
                });
            }, {
                threshold: 0.5
            });

            counters.forEach(counter => {
                counterObserver.observe(counter);
            });
        });
    </script>

    <script>
        function adjustForScrollbar() {
            const mainHeader = document.querySelector('.main-header');
            if (mainHeader) {
                const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
                mainHeader.style.paddingLeft = `calc(2rem + ${scrollbarWidth}px)`;
            }
        }

        window.addEventListener('resize', adjustForScrollbar);
        adjustForScrollbar();
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const dropdowns = document.querySelectorAll('.attributions-dropdown');

            dropdowns.forEach(dropdown => {
                const toggle = dropdown.querySelector('.attributions-toggle');
                toggle.addEventListener('click', () => {
                    dropdown.classList.toggle('open');
                });
            });
        });
    </script>

    <script>
        // Text Scramble Effect (Improved Version)
        class TextScramble {
            constructor(el) {
                this.el = el;
                this.chars = '!<>-_\\/[]{}â€”=+*^?#_';
                this.update = this.update.bind(this);
            }
            setText(newText) {
                const oldText = this.el.innerText;
                const length = Math.max(oldText.length, newText.length);
                const promise = new Promise((resolve) => this.resolve = resolve);
                this.queue = [];
                for (let i = 0; i < length; i++) {
                    const from = oldText[i] || '';
                    const to = newText[i] || '';
                    const start = Math.floor(Math.random() * 60);
                    const end = start + Math.floor(Math.random() * 60);
                    this.queue.push({ from, to, start, end });
                }
                cancelAnimationFrame(this.frameRequest);
                this.frame = 0;
                this.update();
                return promise;
            }
            update() {
                let output = '';
                let complete = 0;
                for (let i = 0, n = this.queue.length; i < n; i++) {
                    let { from, to, start, end, char } = this.queue[i];
                    if (this.frame >= end) {
                        complete++;
                        output += to;
                    } else if (this.frame >= start) {
                        if (!char || Math.random() < 0.28) {
                            char = this.randomChar();
                            this.queue[i].char = char;
                        }
                        output += `<span class="scramble-char">${char}</span>`;
                    } else {
                        output += from;
                    }
                }
                this.el.innerHTML = output;
                if (complete === this.queue.length) {
                    this.resolve();
                    this.el.style.minWidth = ''; // Clean up style
                    this.el.style.minHeight = ''; // Clean up style
                } else {
                    this.frameRequest = requestAnimationFrame(this.update);
                    this.frame++;
                }
            }
            randomChar() {
                return this.chars[Math.floor(Math.random() * this.chars.length)];
            }
        }

        // --- Initialize Scramble on Scroll ---
        document.addEventListener('DOMContentLoaded', () => {
            const scrambleElements = document.querySelectorAll('.animate-text-scramble');

            scrambleElements.forEach(el => {
                const fx = new TextScramble(el);
                const originalText = el.innerText;

                // Get dimensions of the final text
                el.style.visibility = 'hidden';
                const { width, height } = el.getBoundingClientRect();
                el.style.visibility = 'visible';
                el.innerHTML = ''; // Clear text to start empty

                const scrambleObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Set min dimensions before animating
                            el.style.minWidth = `${width}px`;
                            el.style.minHeight = `${height}px`;
                            fx.setText(originalText);
                            scrambleObserver.unobserve(el);
                        }
                    });
                }, { threshold: 0.9 });

                scrambleObserver.observe(el);
            });
        });
    </script>



</body>

</html>

